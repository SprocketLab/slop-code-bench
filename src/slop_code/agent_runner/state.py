"""Agent state management models."""

from __future__ import annotations

from enum import Enum

from pydantic import BaseModel
from pydantic import Field


class AgentStateEnum(str, Enum):
    """Enumeration of possible agent execution states.

    States:
        PENDING: Agent is waiting to start
        INITIALIZED: Agent has been initialized but not started
        RUNNING: Agent is actively executing
        EVALUATING: Agent execution is being evaluated
        FAILED: Agent execution failed (non-error)
        COMPLETED: Agent execution completed successfully
        ERROR: Agent execution encountered an error
        HIT_RATE_LIMITED: Agent execution hit the net rate limit
    """

    PENDING = "pending"
    INITIALIZED = "initialized"
    RUNNING = "running"
    EVALUATING = "evaluating"
    FAILED = "failed"
    COMPLETED = "completed"
    ERROR = "error"
    HIT_RATE_LIMITED = "hit_rate_limited"


class AgentStats(BaseModel):
    """Statistics for agent execution tracking.

    Attributes:
        input_tokens: Number of input tokens consumed
        generated_tokens: Number of tokens generated by the agent
        reasoning_tokens: Number of reasoning tokens used
        total_tokens: Total number of tokens used
        steps: Number of execution steps taken
        cost: Total cost incurred in dollars
    """

    input_tokens: int = 0
    generated_tokens: int = 0
    reasoning_tokens: int = 0
    total_tokens: int = 0
    steps: int = 0
    cost: float = 0

    def step(
        self,
        cost: float,
        total_tokens: int,
        input_tokens: int,
        generated_tokens: int = 0,
        reasoning_tokens: int = 0,
    ) -> None:
        """Update stats with absolute values for a new step.

        Replaces current values with new values and increments step count.

        Args:
            cost: Cost for this step
            total_tokens: Total tokens used after this step
            input_tokens: Input tokens used after this step
            generated_tokens: Generated tokens after this step
            reasoning_tokens: Reasoning tokens after this step
        """
        self.input_tokens = input_tokens
        self.generated_tokens = generated_tokens
        self.reasoning_tokens = reasoning_tokens
        self.total_tokens = total_tokens
        self.steps += 1
        self.cost = cost

    def delta_step(
        self,
        cost: float,
        total_tokens: int,
        input_tokens: int,
        generated_tokens: int,
        reasoning_tokens: int,
    ) -> None:
        """Update stats with delta values for a new step.

        Adds delta values to current values and increments step count.

        Args:
            cost: Additional cost for this step
            total_tokens: Additional tokens used in this step
            input_tokens: Additional input tokens used in this step
            generated_tokens: Additional tokens generated in this step
            reasoning_tokens: Additional reasoning tokens used in this step
        """
        self.input_tokens += input_tokens
        self.generated_tokens += generated_tokens
        self.reasoning_tokens += reasoning_tokens
        self.total_tokens += total_tokens
        self.steps += 1
        self.cost += cost


class AgentState(BaseModel):
    """Complete state tracking for an agent execution.

    Maintains both checkpoint-specific and cumulative statistics
    across the entire agent execution lifecycle.

    Attributes:
        state: Current execution state
        checkpoint: Statistics for the current checkpoint only
        total: Cumulative statistics across all checkpoints
    """

    state: AgentStateEnum = AgentStateEnum.INITIALIZED
    checkpoint: AgentStats = Field(default_factory=AgentStats)
    total: AgentStats = Field(default_factory=AgentStats)

    @classmethod
    def initialize(cls) -> AgentState:
        """Create a new initialized AgentState.

        Returns:
            AgentState in INITIALIZED state with empty stats
        """
        return cls(
            state=AgentStateEnum.INITIALIZED,
            checkpoint=AgentStats(),
            total=AgentStats(),
        )

    def calculate_delta(
        self,
        total_tokens: int,
        cost: float,
        input_tokens: int = 0,
        generated_tokens: int = 0,
        reasoning_tokens: int = 0,
    ) -> dict[str, int | float]:
        """Calculate delta between new values and current checkpoint stats.

        Args:
            total_tokens: New total tokens value
            cost: New cost value
            input_tokens: New input tokens value
            generated_tokens: New generated tokens value
            reasoning_tokens: New reasoning tokens value

        Returns:
            Dictionary with delta values for each metric
        """
        return {
            "total_tokens": total_tokens - self.checkpoint.total_tokens,
            "cost": cost - self.checkpoint.cost,
            "input_tokens": input_tokens - self.checkpoint.input_tokens,
            "generated_tokens": generated_tokens - self.checkpoint.generated_tokens,
            "reasoning_tokens": reasoning_tokens - self.checkpoint.reasoning_tokens,
        }

    def step(
        self,
        total_tokens: int,
        cost: float,
        input_tokens: int = 0,
        generated_tokens: int = 0,
        reasoning_tokens: int = 0,
        use_delta: bool = True,
    ) -> None:
        """Update state with new execution step data.

        Updates checkpoint stats with absolute values and total stats
        with delta values to maintain cumulative tracking.

        Args:
            total_tokens: Total tokens after this step
            cost: Total cost after this step
            input_tokens: Input tokens after this step
            generated_tokens: Generated tokens after this step
            reasoning_tokens: Reasoning tokens after this step
            use_delta: Whether to use delta calculation (default: True)
        """
        delta = self.calculate_delta(
            total_tokens=total_tokens,
            cost=cost,
            input_tokens=input_tokens,
            generated_tokens=generated_tokens,
            reasoning_tokens=reasoning_tokens,
        )

        self.checkpoint.step(
            total_tokens=total_tokens,
            cost=cost,
            input_tokens=input_tokens,
            generated_tokens=generated_tokens,
            reasoning_tokens=reasoning_tokens,
        )
        # Delta step b/c the total stats are not reset between checkpoints
        self.total.delta_step(**delta)

    def new_checkpoint(self) -> None:
        """Reset checkpoint stats for a new checkpoint."""
        self.checkpoint = AgentStats()


class AgentProgress(BaseModel):
    """Progress snapshot of the agent execution.

    Provides a snapshot view of agent progress at a point in time,
    including both checkpoint-specific and cumulative metrics.

    Attributes:
        checkpoint_tokens: Tokens used in current checkpoint
        checkpoint_steps: Steps taken in current checkpoint
        checkpoint_cost: Cost incurred in current checkpoint
        total_tokens: Total tokens used across all checkpoints
        total_steps: Total steps taken across all checkpoints
        total_cost: Total cost incurred across all checkpoints
    """

    checkpoint_tokens: int
    checkpoint_steps: int
    checkpoint_cost: float
    total_tokens: int
    total_steps: int
    total_cost: float
