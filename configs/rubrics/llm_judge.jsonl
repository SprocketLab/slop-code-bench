{"name": "narration_comments", "category": "documentation_noise", "type": "verbosity", "description": "Comments that narrate code flow with phrases like 'Step 1:', 'First,', 'Now we', 'Next,' immediately before code that does exactly what the comment says.", "positive_indicators": ["'# Step 1: Initialize the list' above 'results = []'", "'# Now we loop through each item' above 'for item in items:'", "'# First, get the user' above 'user = get_user(id)'", "'# Next, validate the input' above 'validate(input)'"], "negative_indicators": ["'# Retry with exponential backoff to handle rate limits' (explains WHY)", "'# HACK: workaround for bug #1234' (provides context)", "'# NOTE: order matters here due to dependency' (non-obvious insight)"]}
{"name": "echo_docstrings", "category": "documentation_noise", "type": "verbosity", "description": "Docstrings that only restate the function name in sentence form without adding parameter details, return values, edge cases, or context.", "positive_indicators": ["'def get_user(id):' with docstring '\"\"\"Gets the user.\"\"\"'", "'def calculate_total():' with docstring '\"\"\"Calculates the total.\"\"\"'", "'def process_data(data):' with docstring '\"\"\"Processes the data.\"\"\"'"], "negative_indicators": ["'def get_user(id):' with '\"\"\"Fetch user by ID.\\n\\nArgs:\\n    id: User's unique identifier\\n\\nReturns:\\n    User object or None if not found\\n\\nRaises:\\n    ConnectionError: If database is unreachable\"\"\"'", "'def calculate_total(items, tax_rate):' with '\"\"\"Sum item prices with tax. Rounds to 2 decimal places. Empty list returns 0.0.\"\"\"'", "'def process_data(data):' with '\"\"\"Transform raw API response for frontend. Call after validate_response().\"\"\"'"]}
{"name": "entry_exit_logging", "category": "documentation_noise", "type": "verbosity", "description": "Logging statements at function entry/exit in short functions (<20 lines) that add no diagnostic value.", "positive_indicators": ["'logger.debug(\"Entering process_item\")' at start of 5-line function", "'log.info(\"Starting...\")' and 'log.info(\"Done.\")' wrapping trivial logic", "'console.log(\"function called\")' at function entry"], "negative_indicators": ["Logging in functions that make external calls or I/O", "Logging with actual variable values for debugging", "Logging in error paths or catch blocks"]}
{"name": "class_prefix_in_members", "category": "naming_and_types", "type": "verbosity", "description": "Class members that redundantly include the class name as a prefix, when the class context already provides that information.", "positive_indicators": ["'class User: user_id, user_name, user_email'", "'class Order: order_items, order_total, order_date'", "'class Config: config_path, config_values'"], "negative_indicators": ["'class User: id, name, email'", "'class Order: items, total, date'", "'class Config: path, values'"]}
{"name": "delegation_only_class", "category": "overengineering", "type": "verbosity", "description": "Classes where every method simply delegates to an underlying object's method of the same name, adding no behavior.", "positive_indicators": ["'class Wrapper: def save(self): return self.delegate.save()'", "Every method is 'return self._inner.method_name(...)'", "Facade class that mirrors the wrapped interface exactly"], "negative_indicators": ["'def save(self): self._validate(); return self._delegate.save()' (adds validation step)", "'def save(self): result = self._delegate.save(); logger.info(f\"Saved {self.id}\"); return result' (adds logging)", "'def get_items(self, limit=None): return self._delegate.fetch_all()[:limit]' (changes signature, adds slicing)"]}
{"name": "lonely_interface", "category": "overengineering", "type": "verbosity", "description": "An interface, abstract base class, or protocol with exactly one implementing class in the entire codebase.", "positive_indicators": ["'class IUserRepository(ABC)' with only 'class UserRepository(IUserRepository)'", "'interface DataSource' with only 'class SqlDataSource implements DataSource'", "'Protocol Validator' with only 'class InputValidator(Validator)'"], "negative_indicators": ["Interface with multiple implementations", "Interface from external library you implement", "Interface for dependency injection in tests (if tests exist)"]}
{"name": "one_subclass_hierarchy", "category": "overengineering", "type": "verbosity", "description": "An abstract base class with exactly one concrete subclass, where the abstraction provides no benefit.", "positive_indicators": ["'class AbstractProcessor' with only 'class ConcreteProcessor(AbstractProcessor)'", "'class BaseHandler' with only 'class RequestHandler(BaseHandler)'", "'class Animal(ABC)' with only 'class Dog(Animal)'"], "negative_indicators": ["Base class with multiple subclasses", "Base class that's part of a framework extension point", "Base class shared across modules with different implementations"]}
{"name": "single_entry_registry", "category": "overengineering", "type": "verbosity", "description": "A registry, map, or dispatch table pattern containing only one entry, negating the purpose of the pattern.", "positive_indicators": ["'handlers = {\"default\": DefaultHandler()}'", "'STRATEGIES = {\"main\": MainStrategy}'", "'registry.register(\"only_one\", implementation)'"], "negative_indicators": ["Registry with multiple entries", "Registry that's populated dynamically at runtime", "Registry that's designed for extension by users"]}
{"name": "factory_returns_constant", "category": "overengineering", "type": "verbosity", "description": "Factory method or class that always returns the same concrete type, with no conditionals or configuration affecting the result.", "positive_indicators": ["'def create_service(): return ConcreteService()'", "'class Factory: def create(self): return OnlyImplementation()'", "'get_handler() -> Handler: return DefaultHandler()'"], "negative_indicators": ["Factory that switches on a type parameter", "Factory that reads configuration to decide type", "Factory that returns different types based on input"]}
{"name": "strategy_never_varies", "category": "overengineering", "type": "verbosity", "description": "Strategy pattern where the strategy field is set once in the constructor and never changed, injected, or selected dynamically.", "positive_indicators": ["'self.strategy = ConcreteStrategy()' in __init__, never reassigned", "'private readonly strategy = new DefaultStrategy();'", "Strategy field with no setter, always same value"], "negative_indicators": ["Strategy passed as constructor parameter", "Strategy selected based on configuration", "Strategy changed at runtime via setter"]}
{"name": "interface_per_class", "category": "overengineering", "type": "verbosity", "description": "Every concrete class has a corresponding interface/protocol, even when only one implementation exists and no mocking is needed.", "positive_indicators": ["'IUserService' paired with only 'UserService'", "'OrderRepositoryInterface' with only 'OrderRepository'", "1:1 interface-to-class ratio throughout codebase"], "negative_indicators": ["Interfaces with multiple implementations", "Interfaces used for test mocking with actual test files present", "Interfaces from dependency injection framework requirements"]}
{"name": "cache_for_literals", "category": "premature_optimization", "type": "verbosity", "description": "Memoization or caching applied to functions that only perform simple arithmetic, string operations, or return constants.", "positive_indicators": ["'@lru_cache def add(a, b): return a + b'", "'@cached def get_name(): return \"default\"'", "Memoizing a pure function with O(1) computation"], "negative_indicators": ["Caching functions that make I/O or network calls", "Caching expensive computations (parsing, sorting large data)", "Caching results of database queries"]}
{"name": "parallel_small_collection", "category": "premature_optimization", "type": "verbosity", "description": "Using threading, multiprocessing, or async parallelism for processing small collections where overhead exceeds benefit.", "positive_indicators": ["'ThreadPoolExecutor' to process list of 5 items", "'Promise.all()' for 2-3 synchronous operations", "'parallel_map' over hardcoded small array", "async/await for CPU-bound operations on small data"], "negative_indicators": ["Parallel processing of large datasets (1000+ items)", "Parallel I/O operations (multiple network requests)", "Parallel processing where item processing is slow"]}
{"name": "lazy_always_accessed", "category": "premature_optimization", "type": "verbosity", "description": "Lazy initialization pattern for values that are unconditionally accessed every time the containing object is used.", "positive_indicators": ["'@property def config(self):' with lazy init, but accessed in every method", "'lazy val x' that's used in the primary code path", "'getInstance()' called in every function using the class"], "negative_indicators": ["Lazy init for expensive resources that might not be needed", "Lazy init for optional features", "Lazy init for breaking circular dependencies"]}
{"name": "redundant_null_check", "category": "defensive_antipatterns", "type": "verbosity", "description": "Checking the same variable for null/None/empty multiple times in close proximity (within 10 lines), or after already establishing it's valid.", "positive_indicators": ["'if user: ... if user is not None:'", "'if items: for item in items: if item:'", "'user = get_user(); if user: ... if user is not None:'"], "negative_indicators": ["Null check after reassignment", "Null check in different branches", "Null check where value could have changed"]}
{"name": "default_on_required_field", "category": "defensive_antipatterns", "type": "verbosity", "description": "Using null coalescing (??, ?., or 'or default') on values that come from constructors, required parameters, or guaranteed sources.", "positive_indicators": ["'self.name ?? \"unknown\"' when name is a required constructor param", "'user?.id' when user comes from authenticated session (always exists)", "'config.timeout or 30' when config is validated at startup"], "negative_indicators": ["Default on optional parameters", "Default on values from external sources (API, user input)", "Default on values that could legitimately be missing"]}
{"name": "silent_truncation", "category": "defensive_antipatterns", "type": "erosion", "description": "Slicing or truncating data to fit limits without logging, validating, or otherwise indicating data loss occurred.", "positive_indicators": ["'name = name[:50]' without length check or warning", "'items = items[:MAX]' silently dropping items", "'text.substring(0, limit)' without logging truncation"], "negative_indicators": ["Truncation with logging when data is cut", "Truncation with validation that input fits", "Truncation documented as expected behavior in spec"]}
{"name": "silent_resource_creation", "category": "hidden_behavior", "type": "erosion", "description": "Automatically creating missing resources (directories, files, database tables) without logging or warning that creation occurred.", "positive_indicators": ["'os.makedirs(path, exist_ok=True)' without logging", "'if not os.path.exists(f): open(f, \"w\").close()'", "'CREATE TABLE IF NOT EXISTS' in application code without logging"], "negative_indicators": ["Resource creation with logging", "Resource creation in explicit setup/init function", "Resource creation documented in spec"]}
{"name": "unrequested_features", "category": "spec_deviation", "type": "verbosity", "description": "Code implements features, flags, options, or capabilities not mentioned anywhere in the spec. Compare implemented functionality against spec requirements.", "positive_indicators": ["CLI flags like --verbose, --dry-run, --config not in spec", "Output format options (JSON, XML, YAML) when spec only asks for one", "Optional parameters for customization spec doesn't mention", "Additional API endpoints beyond spec requirements"], "negative_indicators": ["Features explicitly requested in spec", "Features required for basic functionality implied by spec", "Standard error handling and logging"]}
{"name": "handling_excluded_cases", "category": "spec_deviation", "type": "verbosity", "description": "Code handles edge cases or inputs that the spec explicitly says won't occur, can be assumed valid, or are out of scope.", "positive_indicators": ["Validation for inputs spec says are 'always valid'", "Empty/null checks when spec guarantees non-empty", "Error handling for cases spec says 'will not happen'", "Unicode handling when spec says 'ASCII only'"], "negative_indicators": ["Handling cases spec says MUST be handled", "Reasonable defensive coding for undefined spec areas", "Validation at true system boundaries"]}
{"name": "scaffold_remnants", "category": "incomplete_implementation", "type": "erosion", "description": "Generated scaffolding left half-implemented, adding noise without behavior.", "positive_indicators": ["Auto-generated controller/service files with TODO bodies", "Routes/endpoints registered that just return 501/Not Implemented", "Placeholder tests that always pass or are skipped"], "negative_indicators": ["Generated stubs that were fully implemented", "Scaffolding kept only in a documented template directory"]}
{"name": "stub_implementations", "category": "incomplete_implementation", "type": "erosion", "description": "Functions or methods that return placeholders instead of real behavior.", "positive_indicators": ["return None/# TODO in business logic", "raise NotImplementedError in code that should run", "Methods that always return hardcoded defaults unrelated to inputs"], "negative_indicators": ["Abstract base classes that are meant to be subclassed", "Temporary stubs clearly marked and skipped in wiring/tests"]}
{"name": "unnecessary_monadic_wrappers", "category": "api_overengineering", "type": "verbosity", "description": "Optional/Maybe/Result wrappers on values that are never optional or errors that still crash.", "positive_indicators": ["Result<T,E> used but errors are immediately .unwrap/.get", "Optional around values guaranteed by construction", "map/flatMap chains replacing simple if/raise"], "negative_indicators": ["Result/Option used to model real absence or recoverable errors", "Functional wrappers that simplify complex branching"]}
{"name": "unnecessary_type_wrappers", "category": "api_overengineering", "type": "verbosity", "description": "Wrapper classes around primitives with no validation or behavior.", "positive_indicators": ["class UserId { String value; } used only to pass strings", "Newtypes immediately unwrapped at API boundaries", "Getters/setters only for a single primitive"], "negative_indicators": ["Wrappers enforcing invariants or formatting", "Types that carry domain behavior (methods, validation)"]}
{"name": "nested_async_flows", "category": "control_flow_complexity", "type": "erosion", "description": "Async callbacks/promises nested inside each other, obscuring execution order.", "positive_indicators": ["fetch().then(...json().then(...)) chains three levels deep", "Callbacks defined inside async handlers inside other callbacks", "Nested awaits wrapping more awaits inline"], "negative_indicators": ["Flat async/await with clear sequencing", "Promise chains that stay linear and readable"]}
{"name": "inline_state_machines", "category": "control_flow_complexity", "type": "erosion", "description": "Implicit state machines implemented by mutating a 'state' variable across branches.", "positive_indicators": ["'state = \"init\"\\nif x: state = \"running\"\\n...\\nif y: state = \"done\"\\nif state == \"running\" and z: state = \"error\"' scattered across function", "'mode = 0\\nfor item in items:\\n    if cond1: mode = 1\\n    if cond2 and mode == 1: mode = 2\\n    process(item, mode)'", "'is_started = False; is_complete = False; has_error = False' with flags toggled in 5+ places"], "negative_indicators": ["Explicit transition tables or enums with clear edges", "State encapsulated in dedicated objects with methods"]}
{"name": "boolean_success_flags", "category": "error_obscuring", "type": "erosion", "description": "Functions returning success booleans instead of raising or returning rich errors.", "positive_indicators": ["(result, ok) tuples where ok must be checked", "Methods returning True/False with no error detail", "APIs that swallow errors and only return status"], "negative_indicators": ["'def contains(item): return item in self._set' (membership check - boolean is appropriate)", "'def save(user): raise ValidationError(\"Email required\")' (exception with detail)", "'def process(data) -> Result[Output, ProcessingError]' (rich error type with context)", "'def try_parse(s): return None' where None clearly means 'not parseable' by convention"]}
{"name": "sentinel_values_as_errors", "category": "error_obscuring", "type": "erosion", "description": "Using magic values to signal errors instead of explicit error handling.", "positive_indicators": ["Return -1/''/0 to mean 'not found' or 'error'", "None/undefined used to mean both 'missing' and 'error'", "Special IDs like 0 meaning 'no user'"], "negative_indicators": ["Documented sentinel values at well-defined boundaries", "Distinct error types or exceptions returned"]}
{"name": "error_message_destruction", "category": "error_obscuring", "type": "erosion", "description": "Replacing specific errors with generic messages, hiding root cause details.", "positive_indicators": ["catch ValidationError then raise Error('Invalid input')", "Returning {error: true} without message/field details", "Logging only 'An error occurred'"], "negative_indicators": ["Sanitizing sensitive details while keeping actionable info", "Adding context while preserving original message/stack"]}
{"name": "retry_loops_hiding_failures", "category": "error_obscuring", "type": "erosion", "description": "Retries that discard intermediate failures, hiding flakiness or root causes.", "positive_indicators": ["for _ in range(3): try: return do() except: pass", "Retry decorator with no on_failure logging", "While loop retrying indefinitely without backoff or trace"], "negative_indicators": ["Retries with logged attempts and surfaced final errors", "Backoff strategies that record failures or metrics"]}
{"name": "lenient_parsing", "category": "defensive_antipatterns", "type": "erosion", "description": "Parsers that accept malformed input by guessing or defaulting, hiding producer bugs.", "positive_indicators": ["int(value) if value.isdigit() else 0", "date parsing that tries many formats silently", "JSON.parse catch returning {} with no error"], "negative_indicators": ["Strict parsing that fails fast on bad data", "Leniency with logging/metrics when accepting loose input"]}
{"name": "type_coercion_hiding_mismatches", "category": "defensive_antipatterns", "type": "erosion", "description": "Implicit/explicit coercion that makes wrong types pass silently.", "positive_indicators": ["id = str(id) to accept any input", "Loose equality like x == '1' matching numbers", "float(value) without validating numeric input"], "negative_indicators": ["Explicit validation with clear errors on type mismatch", "Coercion only in user-facing input layers with logging"]}
{"name": "defensive_cloning_hiding_mutation", "category": "defensive_antipatterns", "type": "verbosity", "description": "Cloning inputs/outputs everywhere to hide unintended mutation instead of fixing it.", "positive_indicators": ["Spread/deepcopy at every function entry", "Getters that always return deep copies of internal state", "Clone before and after trivial operations"], "negative_indicators": ["Cloning around known mutating calls to contain side effects", "Immutability enforced at boundaries to prevent mutation bugs"]}
{"name": "handrolled_standard_operations", "category": "code_quality", "type": "verbosity", "description": "Reimplementing common library utilities instead of using built-ins.", "positive_indicators": ["Manual string split/trim when built-ins exist", "Custom reduce/map implementations for simple cases", "Home-grown retry/backoff when library helpers exist"], "negative_indicators": ["Custom logic because built-ins lack needed behavior", "Performance-tuned implementations with evidence"]}
{"name": "log_level_hiding", "category": "debug_blind_spots", "type": "erosion", "description": "Logging important diagnostics at levels filtered out in production.", "positive_indicators": ["Exceptions logged at DEBUG/TRACE only", "Request/response errors logged at very low levels", "Root causes logged at levels typically disabled"], "negative_indicators": ["Errors logged at INFO/ERROR where they are visible", "Debug logging gated by config but with fallback alerts"]}
{"name": "correlation_id_absence", "category": "debug_blind_spots", "type": "erosion", "description": "Lack of correlation/request IDs in async or distributed flows, making tracing impossible.", "positive_indicators": ["'logger.info(f\"Processing order {order.id}\")' without request_id in distributed system", "'executor.submit(process, item)' where process() logs but has no trace context", "'queue.put({\"action\": \"send_email\", \"to\": user})' with no correlation to triggering HTTP request", "'logger.error(\"Payment failed\")' in service B with no way to correlate to service A's request"], "negative_indicators": ["Consistent propagation of trace/request IDs", "Context-managed logging that preserves correlation"]}
{"name": "implicit_default_parameters", "category": "hidden_behavior", "type": "erosion", "description": "Behavior-changing parameters defaulted in code so callers trigger modes without realizing.", "positive_indicators": ["Important options with defaults buried in function signatures", "Flags like cache=True, limit=1000 that silently alter behavior", "Mode parameters defaulting to a non-neutral behavior"], "negative_indicators": ["Defaults documented and surfaced at call sites", "Defaults that are neutral/no-op behaviors"]}
{"name": "silent_fallbacks", "category": "hidden_behavior", "type": "erosion", "description": "Fallback chains that hide which path succeeded, masking primary failures.", "positive_indicators": ["try primary then secondary with no logging", "value = a or b or c with no trace of source", "Config/env resolution with multiple tiers and no visibility"], "negative_indicators": ["Fallbacks with logging/metrics of which source was used", "Explicit propagation of which path handled the request"]}
{"name": "auto_correction_without_warning", "category": "hidden_behavior", "type": "erosion", "description": "Silently fixing bad config/input (clamping, auto-creating resources) instead of failing or warning.", "positive_indicators": ["Clamping timeouts/ranges without logging", "auto-mkdir for missing paths in core logic", "Normalizing invalid options to defaults quietly"], "negative_indicators": ["Corrections logged/alerted with clear visibility", "Validation errors raised for invalid inputs/config"]}
{"name": "null_coalescing_abuse", "category": "defensive_antipatterns", "type": "verbosity", "description": "Using ??/or defaults on values that should never be null, hiding real bugs.", "positive_indicators": ["Required config/env vars defaulted to hardcoded values", "user?.id or self.name or \"unknown\" on required fields", "Chaining ?. on objects that must exist by spec"], "negative_indicators": ["Defaults only on truly optional fields", "Guarded access at external/input boundaries with logging"]}
{"name": "stringly_typed_logic", "category": "naming_and_types", "type": "erosion", "description": "Using raw strings for modes/types/states instead of enums/constants.", "positive_indicators": ["Status/mode comparisons on repeated string literals", "Dispatch on string names of actions", "String unions used where types/enums would be clearer"], "negative_indicators": ["Typed enums or constants referenced consistently", "String use only at IO boundaries with conversion to types"]}
{"name": "ignoring_return_values", "category": "code_quality", "type": "erosion", "description": "Calling functions where return values matter but are unused, risking missed errors/results.", "positive_indicators": ["repo.save(user) without checking result/status", "API calls whose responses are dropped", "Helper returning updated object ignored"], "negative_indicators": ["Explicitly fire-and-forget calls documented as such", "Deliberate ignoring with comment because return is irrelevant"]}
{"name": "validation_mismatch", "category": "spec_validation", "type": "verbosity", "description": "Validation rules that contradict or misalign with the spec/domain.", "positive_indicators": ["Rejecting inputs the spec allows", "Allowing inputs the spec forbids", "Validation messages that don't match enforced rules"], "negative_indicators": ["Validation logic matching documented requirements", "Flexible validation explicitly allowed by the spec"]}
{"name": "validation_theater", "category": "spec_validation", "type": "verbosity", "description": "Validation code that runs but doesn't change outcomes (no raises, ignores failures).", "positive_indicators": ["validate() return value ignored", "Errors collected but never surfaced", "Checks that only log but proceed on invalid data"], "negative_indicators": ["'errors = validate(data); if errors: raise ValidationError(errors)' (failures stop execution)", "'if not is_valid(x): return {\"error\": \"Invalid x\", \"field\": \"x\", \"value\": x}' (surfaced to caller)", "'warnings = check(data); if warnings: logger.warning(f\"Proceeding with warnings: {warnings}\")' (visible warnings)"]}
{"name": "domain_blind_normalization", "category": "spec_validation", "type": "erosion", "description": "Normalization that discards domain meaning, corrupting data silently.", "positive_indicators": ["Lowercasing IDs that are case-sensitive", "Truncating fields without domain rules", "Stripping characters that carry meaning (e.g., leading zeros)"], "negative_indicators": ["Normalization aligned with domain rules (e.g., emails case-folded locally)", "Validation that rejects out-of-domain formats instead of altering them"]}
